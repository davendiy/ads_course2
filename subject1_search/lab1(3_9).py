#!/usr/bin/env python3
# -*-encoding: utf-8-*-

# by David Zashkol
# 2 course, comp math
# Taras Shevchenko National University of Kyiv
# email: davendiy@gmail.com

"""
Скоро новый год и Санта-Клаус уже начал готовить свою волшебную оленью упряжку,
на которой он развозит подарки детям.
Известно, что упряжку везут несколько волшебных оленей,
на каждом из которых едут два эльфа.

Но волшебные олени – строптивые животные, поэтому не любые два эльфа могут ехать на любом олене.
А именно, каждый олень характеризуется некоторой строптивостью ai,
а каждый эльф – темпераментом bi.
Два эльфа j и k могут ехать на i-м олене в том и только в том случае,
если либо bj < ai < bk, либо bk < ai < bj.

Чтобы его появление было максимально зрелищным, Санта-Клаус хочет,
чтобы в его упряжке было как можно больше оленей.
Про каждого оленя Санта знает его строптивость, а про каждого эльфа – его темперамент.

Помогите Санте выяснить, какое максимальное количество оленей он сможет включить в упряжку,
каких оленей ему следует выбрать, и какие эльфы должны на них ехать.

Входные данные
В первой строке вводятся два целых числа m и n – количество оленей и эльфов,
соответственно ( 1 <= m, n <= 100 000).

Вторая строка содержит m целых чисел ai – строптивость оленей
( 0 <= ai <= 10^9).
В третьей строке записаны n целых чисел bi – темперамент эльфов ( 0 <= bi <= 10^9).

Выходные данные
В первой строке  выведите одно число k – максимальное количество оленей,
которое Санта-Клаус может включить в свою упряжку.
В следующих k строках выведите по три целых числа:
di, ei, 1, ei, 2 – для каждого оленя в упряжке выведите его номер и номера эльфов,
которые на нем поедут. Если решений несколько, выведите любое.

И эльфы, и олени пронумерованы, начиная с единицы, в том порядке, в котором они заданы во входных данных.

Пример:
4 6
2 3 4 5
1 3 2 2 5 2
https://informatics.msk.ru/mod/statements/view3.php?id=1966&chapterid=414
"""


def read_line(message, len_list):
    s = input(message)
    s = s.split()
    s = list(map(lambda a, i: (int(a), i + 1), s, range(len_list)))
    s.sort(key=lambda a: a[0])
    return s


def find_elf(list1: list, list2: list):
    rez = []
    for deer in list1:             # проходимо по всіх оленях і кожному шукаємо пару ельфів
        first_elf = None
        second_elf = None
        for elf in list2:
            # якщо ельф уже більший, а меншого не знайшли
            if elf[0] >= deer[0] and first_elf is None:
                break

            # якщо меньшого не знайшли, а ельф меньший
            elif first_elf is None:
                first_elf = elf

            # якщо меньшого знайшли, а ельф більший
            elif elf[0] > deer[0]:
                second_elf = elf     # запам'ятовуємо його
                break
        if second_elf and first_elf:
            rez.append((deer[1], first_elf[1], second_elf[1]))
            list2.remove(first_elf)
            list2.remove(second_elf)
        else:
            break

    return rez


if __name__ == '__main__':
    list_length = list(map(int, input("").split()))
    array1 = read_line('', list_length[0])
    array2 = read_line('', list_length[1])
    result = find_elf(array1, array2)
    print(len(result))
    for tmp in result:
        print('{} {} {}'.format(*tmp))
